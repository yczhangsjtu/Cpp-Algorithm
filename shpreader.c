#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb-master/stb_image_write.h"

#define MAX_FILE_NAME 256

typedef unsigned char BYTE;
typedef short int WORD;
typedef int LONGINT;

typedef struct Color{
	BYTE c[4];
} Color;

typedef struct FileHeader{
	WORD check;
	WORD width;
	WORD height;
	WORD num;
} FileHeader;

typedef struct ImageHeader{
	WORD x,y,w,h;
	BYTE compression;
	BYTE align[3];
	Color transparent;
	LONGINT zero,offset;
} ImageHeader;

typedef struct ImageData{
	ImageHeader header;
	BYTE * data;
} ImageData;

int debug = 0;

void allocImageData(ImageData *imageData)
{
	LONGINT size = imageData->header.w * imageData->header.h;
	imageData->data = (BYTE*)malloc(size * sizeof(LONGINT));
}

void freeImageData(ImageData *imageData)
{
	free(imageData->data);
	imageData->data = NULL;
}

void usage()
{
	fprintf(stderr,"Usage: shpreader -i inputfile -o outputfile [options]");
	fprintf(stderr,"\t-v verbose mode");
	fprintf(stderr,"\t-p filename palatte file");
	fprintf(stderr,"\t-s from");
	fprintf(stderr,"\t-s to");
	exit(1);
}

void decompress1(BYTE *dst, BYTE *src, WORD w, WORD h)
{
	memcpy(dst,src,w*h);
}
void decompress2(BYTE *dst, BYTE *src, WORD w, WORD h)
{
	
}
void decompress3(BYTE *dst, BYTE *src, WORD w, WORD h)
{
	BYTE *psrc = src, *pdst = dst;
	BYTE v;
	WORD pos, count, x, y, i;
	for(y = 0; y < h; y++)
	{
		pos = *((WORD*)psrc);
		count = pos-2;
		psrc += 2;
		x = 0;
		/*
		if(debug)
		{
			printf("%d.%d: ",y,count);
			for(i = 0; i < count; i++)
				printf("%x%x ",psrc[i]/16,psrc[i]%16);
			printf("\n");
		}
		*/
		for(i = 0; i < count; i++)
		{
			v = *psrc++;
			if(v)
			{
				*pdst++ = v;
				x++;
			}
			else
			{
				v = *psrc++;
				i++;
				while(v > 0 && x < w)
				{
					*pdst++ = 0;
					x++;
					v--;
				}
			}
		}
		assert(x == w);
	}
}

BYTE defaultPalatte[][3] =
{
	{0x00,0x00,0x00}, {0x2a,0x00,0x2a}, {0x00,0x2a,0x2a}, {0x00,0x2a,0x00},
	{0x15,0x3f,0x15}, {0x3f,0x3f,0x15}, {0x3f,0x15,0x15}, {0x2a,0x15,0x00},
	{0x2a,0x00,0x00}, {0x15,0x3f,0x3f}, {0x14,0x14,0x3f}, {0x00,0x00,0x2a},
	{0x00,0x00,0x00}, {0x15,0x15,0x15}, {0x2a,0x2a,0x2a}, {0x3f,0x3f,0x3f},
	{0x3f,0x00,0x00}, {0x3b,0x00,0x00}, {0x37,0x00,0x00}, {0x34,0x00,0x00},
	{0x30,0x00,0x00}, {0x2c,0x00,0x00}, {0x29,0x00,0x00}, {0x25,0x00,0x00},
	{0x21,0x00,0x00}, {0x1e,0x00,0x00}, {0x1a,0x00,0x00}, {0x16,0x00,0x00},
	{0x13,0x00,0x00}, {0x0f,0x00,0x00}, {0x0b,0x00,0x00}, {0x08,0x00,0x00},
	{0x3f,0x3f,0x3f}, {0x3d,0x3d,0x3d}, {0x3b,0x3b,0x3b}, {0x38,0x38,0x38},
	{0x36,0x36,0x36}, {0x34,0x34,0x34}, {0x32,0x32,0x32}, {0x30,0x30,0x30},
	{0x2e,0x2e,0x2e}, {0x2c,0x2c,0x2c}, {0x2a,0x2a,0x2a}, {0x28,0x28,0x28},
	{0x26,0x26,0x26}, {0x24,0x24,0x24}, {0x22,0x22,0x22}, {0x20,0x20,0x20},
	{0x1e,0x1e,0x1e}, {0x1c,0x1c,0x1c}, {0x1a,0x1a,0x1a}, {0x18,0x18,0x18},
	{0x15,0x15,0x15}, {0x13,0x13,0x13}, {0x11,0x11,0x11}, {0x0f,0x0f,0x0f},
	{0x0d,0x0d,0x0d}, {0x0b,0x0b,0x0b}, {0x09,0x09,0x09}, {0x07,0x07,0x07},
	{0x05,0x05,0x05}, {0x03,0x03,0x03}, {0x01,0x01,0x01}, {0x00,0x00,0x00},
	{0x34,0x34,0x2e}, {0x31,0x31,0x2b}, {0x2e,0x2e,0x28}, {0x2b,0x2b,0x25},
	{0x28,0x28,0x22}, {0x25,0x25,0x1f}, {0x22,0x22,0x1c}, {0x1f,0x1f,0x19},
	{0x1c,0x1c,0x16}, {0x19,0x19,0x13}, {0x16,0x16,0x10}, {0x13,0x13,0x0d},
	{0x10,0x10,0x0a}, {0x0d,0x0d,0x07}, {0x0a,0x0a,0x04}, {0x07,0x07,0x01},
	{0x37,0x37,0x3d}, {0x34,0x34,0x3a}, {0x31,0x31,0x37}, {0x2e,0x2e,0x34},
	{0x2b,0x2b,0x31}, {0x28,0x28,0x2e}, {0x25,0x25,0x2b}, {0x22,0x22,0x28},
	{0x1f,0x1f,0x25}, {0x1c,0x1c,0x22}, {0x19,0x19,0x1f}, {0x16,0x16,0x1c},
	{0x13,0x13,0x19}, {0x10,0x10,0x16}, {0x0d,0x0d,0x13}, {0x0a,0x0a,0x10},
	{0x3b,0x2f,0x2b}, {0x38,0x2c,0x28}, {0x35,0x29,0x25}, {0x32,0x26,0x22},
	{0x2f,0x23,0x1f}, {0x2c,0x20,0x1c}, {0x29,0x1d,0x19}, {0x26,0x1a,0x16},
	{0x23,0x17,0x13}, {0x20,0x14,0x10}, {0x1d,0x11,0x0d}, {0x1a,0x0e,0x0a},
	{0x17,0x0b,0x07}, {0x14,0x08,0x04}, {0x11,0x05,0x01}, {0x0d,0x01,0x00},
	{0x22,0x20,0x16}, {0x20,0x1e,0x15}, {0x1e,0x1d,0x14}, {0x1d,0x1b,0x13},
	{0x1c,0x1a,0x12}, {0x1a,0x18,0x11}, {0x18,0x16,0x10}, {0x16,0x14,0x0f},
	{0x14,0x12,0x0e}, {0x12,0x10,0x0c}, {0x0e,0x0e,0x0a}, {0x0c,0x0c,0x09},
	{0x0b,0x0b,0x08}, {0x0a,0x0a,0x07}, {0x08,0x08,0x05}, {0x06,0x06,0x03},
	{0x35,0x2f,0x1e}, {0x33,0x2d,0x1c}, {0x31,0x2b,0x1c}, {0x2f,0x29,0x1a},
	{0x2b,0x27,0x1a}, {0x29,0x25,0x18}, {0x27,0x23,0x16}, {0x25,0x21,0x14},
	{0x23,0x1e,0x14}, {0x21,0x1c,0x12}, {0x1e,0x1a,0x10}, {0x1c,0x18,0x0f},
	{0x1a,0x18,0x12}, {0x19,0x17,0x11}, {0x18,0x16,0x10}, {0x17,0x15,0x10},
	{0x2f,0x24,0x0f}, {0x2c,0x23,0x0e}, {0x29,0x21,0x0e}, {0x26,0x1e,0x0e},
	{0x23,0x1c,0x0e}, {0x21,0x1b,0x0e}, {0x1e,0x19,0x0e}, {0x1c,0x17,0x0c},
	{0x1b,0x16,0x0b}, {0x1a,0x15,0x0b}, {0x19,0x14,0x0a}, {0x18,0x13,0x0a},
	{0x17,0x12,0x0a}, {0x16,0x12,0x0a}, {0x15,0x11,0x0a}, {0x13,0x10,0x0a},
	{0x11,0x0e,0x09}, {0x0f,0x0d,0x08}, {0x0d,0x0b,0x08}, {0x0b,0x09,0x07},
	{0x0a,0x08,0x07}, {0x09,0x07,0x07}, {0x08,0x07,0x07}, {0x06,0x06,0x06},
	{0x22,0x2f,0x1d}, {0x1d,0x2b,0x18}, {0x18,0x27,0x13}, {0x14,0x24,0x0f},
	{0x11,0x20,0x0b}, {0x0d,0x1d,0x08}, {0x0a,0x19,0x05}, {0x08,0x16,0x03},
	{0x3f,0x3f,0x1c}, {0x3f,0x3d,0x1b}, {0x3f,0x3a,0x1a}, {0x3f,0x38,0x19},
	{0x3f,0x36,0x18}, {0x3f,0x34,0x18}, {0x3f,0x30,0x16}, {0x3d,0x2d,0x14},
	{0x3b,0x2b,0x12}, {0x39,0x25,0x0c}, {0x35,0x1e,0x04}, {0x31,0x18,0x00},
	{0x2d,0x12,0x00}, {0x29,0x0e,0x00}, {0x26,0x0a,0x00}, {0x22,0x06,0x00},
	{0x2c,0x2c,0x3f}, {0x25,0x25,0x39}, {0x1f,0x1f,0x33}, {0x1a,0x1a,0x2d},
	{0x15,0x15,0x27}, {0x10,0x10,0x21}, {0x0c,0x0c,0x1b}, {0x09,0x09,0x16},
	{0x3f,0x00,0x00}, {0x34,0x00,0x00}, {0x29,0x00,0x00}, {0x1f,0x00,0x00},
	{0x3f,0x00,0x3f}, {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f},
	{0x37,0x3d,0x3f}, {0x34,0x3b,0x3e}, {0x33,0x39,0x3d}, {0x30,0x37,0x3d},
	{0x2e,0x35,0x3c}, {0x2c,0x33,0x3b}, {0x2a,0x31,0x3b}, {0x28,0x2f,0x3a},
	{0x27,0x2c,0x39}, {0x25,0x2a,0x39}, {0x22,0x26,0x34}, {0x1f,0x23,0x30},
	{0x1c,0x20,0x2b}, {0x19,0x1c,0x27}, {0x16,0x19,0x22}, {0x13,0x16,0x1e},
	{0x39,0x3c,0x3f}, {0x35,0x39,0x3d}, {0x32,0x36,0x3b}, {0x2f,0x34,0x39},
	{0x2b,0x31,0x37}, {0x28,0x2f,0x35}, {0x26,0x2d,0x33}, {0x23,0x2b,0x31},
	{0x21,0x29,0x31}, {0x1e,0x28,0x2f}, {0x1c,0x27,0x2e}, {0x1a,0x25,0x2d},
	{0x18,0x24,0x2c}, {0x15,0x23,0x2b}, {0x14,0x22,0x2a}, {0x12,0x21,0x29},
	{0x3f,0x3f,0x3f}, {0x31,0x31,0x32}, {0x28,0x28,0x29}, {0x20,0x20,0x21},
	{0x18,0x18,0x19}, {0x00,0x32,0x00}, {0x3f,0x3f,0x00}, {0x3f,0x2f,0x00},
	{0x3f,0x1f,0x00}, {0x3f,0x00,0x00}, {0x2f,0x00,0x00}, {0x33,0x33,0x3f},
	{0x26,0x26,0x3f}, {0x19,0x19,0x3f}, {0x00,0x00,0x3f}, {0x3f,0x3f,0x3f}
};

int main(int argc, char *argv[])
{
	assert(sizeof(BYTE)==1 && sizeof(WORD)==2 && sizeof(LONGINT)==4);
	
	LONGINT i = 1, imageSize = 0, d, s, k, j, x, y, w, h, X, Y, n;
	WORD from = 0, to = -1;
	char input[MAX_FILE_NAME+1] = "";
	char output[MAX_FILE_NAME+1] = "";
	char palatte[MAX_FILE_NAME+1] = "";
	FILE *file = NULL;
	FileHeader fileHeader;
	ImageHeader *pImageHeader = NULL;
	ImageData *imageDatas = NULL;
	BYTE *imageData = NULL, *data = NULL;
	
	while(i < argc)
	{
		if(strcmp(argv[i],"-i") == 0)
		{
			strncpy(input,argv[i+1],MAX_FILE_NAME);
			i++;
		}
		else if(strcmp(argv[i],"-o") == 0)
		{
			strncpy(output,argv[i+1],MAX_FILE_NAME);
			i++;
		}
		else if(strcmp(argv[i],"-p") == 0)
		{
			strncpy(palatte,argv[i+1],MAX_FILE_NAME);
			i++;
		}
		else if(strcmp(argv[i],"-s") == 0)
		{
			from = atoi(argv[i+1]);
			i++;
		}
		else if(strcmp(argv[i],"-e") == 0)
		{
			to = atoi(argv[i+1]);
			i++;
		}
		else if(strcmp(argv[i],"-v") == 0)
			debug = 1;

		i++;
	}
	if(!(strlen(input) && strlen(output)))
		usage();
	
	if(debug)
	{
		printf("Input file: %s\n",input);
		printf("Output file: %s\n",output);
		if(strlen(palatte))
			printf("Palatte file: %s\n",palatte);
	}

	if(strlen(palatte))
	{
		file = fopen(palatte, "rb");
		if(!file) perror(input);
		fread((BYTE*)defaultPalatte,3*sizeof(BYTE),256,file);
		fclose(file);
	}

	if(debug)
	{
		printf("Palatte:\n");
		for(i = 0; i < 64; i++)
			printf("(%d,%d,%d) (%d,%d,%d) (%d,%d,%d) (%d,%d,%d)\n",
				defaultPalatte[i*4][0],defaultPalatte[i*4][1],defaultPalatte[i*4][2],
				defaultPalatte[i*4+1][0],defaultPalatte[i*4+1][1],defaultPalatte[i*4+1][2],
				defaultPalatte[i*4+2][0],defaultPalatte[i*4+2][1],defaultPalatte[i*4+2][2],
				defaultPalatte[i*4+3][0],defaultPalatte[i*4+3][1],defaultPalatte[i*4+3][2]
			);
	}
	
	file = fopen(input, "rb");
	if(!file) perror(input);
	
	fread(&fileHeader, sizeof(fileHeader), 1, file);
	
	if(fileHeader.check)
		perror("Check nonzero.\n");
	
	if(debug)
	{
		printf("Image Width: %d\n",fileHeader.width);
		printf("Image Height: %d\n",fileHeader.height);
		printf("Image Number: %d\n",fileHeader.num);
	}
	n = fileHeader.num;
	
	if(!(fileHeader.width && fileHeader.height))
		perror("Zero size.\n");
	
	if(!fileHeader.num)
		perror("Zero number of images.\n");
	
	if(from >= n)
		perror("'From' bigger than #images.");
	if(to > n)
		perror("'To' bigger than #images.");
	
	imageDatas = (ImageData*)malloc(n * sizeof(ImageData));
	
	for(i = 0; i < n; i++)
		fread(&imageDatas[i].header, sizeof(ImageHeader), 1, file);
	
	for(i = 0; i < n; i++)
	{
		pImageHeader = &imageDatas[i].header;
		if(debug)
		{
			printf("Processing image #%d:\n",i);
			printf("\tx: %d, y: %d, width: %d, height: %d\n",
				pImageHeader->x, pImageHeader->y,
				pImageHeader->w, pImageHeader->h);
			printf("\tCompression type: %d\n",pImageHeader->compression);
			printf("\tAlign: %d,%d,%d\n",
				pImageHeader->align[0], pImageHeader->align[1], pImageHeader->align[2]);
			printf("\tTransparent color: (%d,%d,%d,%d)\n",
				pImageHeader->transparent.c[0], pImageHeader->transparent.c[1],
				pImageHeader->transparent.c[2], pImageHeader->transparent.c[3]);
			printf("\tOffset: %d\n",pImageHeader->offset);
		}
		
		if(pImageHeader->compression == 1)
			imageSize = pImageHeader->w * pImageHeader->h;
		else
		{
			if(i == n - 1)
			{
				fseek(file,0L,SEEK_END);
				imageSize = ftell(file) - pImageHeader->offset;
			}
			else
			{
				imageSize = imageDatas[i+1].header.offset - pImageHeader->offset;
				if(imageSize <= 0)
				{
					fseek(file,0L,SEEK_END);
					imageSize = ftell(file) - pImageHeader->offset;
					n = i+1;
				}
			}
		}
		
		if(debug)
		{
			printf("\tImage data size: %d\n",imageSize);
		}
		
		fseek(file,pImageHeader->offset,SEEK_SET);
		allocImageData(&imageDatas[i]);
		imageData = (BYTE*)malloc(imageSize * sizeof(BYTE));
		fread(imageData,sizeof(BYTE),imageSize,file);
		if(pImageHeader->compression == 1)
			decompress1(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
		if(pImageHeader->compression == 2)
			decompress2(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
		if(pImageHeader->compression == 3)
			decompress3(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
		free(imageData);
	}
	
	if(to <= from) to = n;

	X = fileHeader.width * (to - from);
	Y = fileHeader.height;
	if(debug)
		printf("Output image size: %d x %d\n",X,Y);
	data = malloc(X * Y * 4);
	if(!data) perror("Memory allocation failed.");
	
	for(k = from; k < to; k++)
	{
		x = imageDatas[k].header.x;
		y = imageDatas[k].header.y;
		w = imageDatas[k].header.w;
		h = imageDatas[k].header.h;
		for(i = 0; i < h; i++)
		{
			for(j = 0; j < w; j++)
			{
				s = i * w + j;
				d = ((i + y) * X + x + j + (k-from) * fileHeader.width) * 4;
				data[d] = defaultPalatte[imageDatas[k].data[s]][0]*4+3;
				data[d+1] = defaultPalatte[imageDatas[k].data[s]][1]*4+3;
				data[d+2] = defaultPalatte[imageDatas[k].data[s]][2]*4+3;
				if(imageDatas[k].data[s]) data[d+3] = 255;
			}
		}
	}
	stbi_write_png(output,X,Y,4,data,X*4);
		
	for(i = 0; i < fileHeader.num; i++)
		freeImageData(&imageDatas[i]);
	free(data);
	free(imageDatas);
	fclose(file);
	
	return 0;
}
